import debug from 'debug';
import { Request, Response } from 'express';
import * as luxon from 'luxon';

import { WebClient } from '@slack/client';

import { EN_WORK_TITLE_KR, EN_WORK_TYPE } from './contants/enum/EN_WORK_TYPE';
import { Groups } from './models/Groups';
import {
  IFuseOverWork,
  IOverWork,
  LogData,
  SlackActionInvocation,
  SlackSlashCommand
} from './models/interface/SlackSlashCommand';
import { TimeRecord } from './models/TimeRecord';
import { Users } from './models/Users';
import { WorkLog } from './models/WorkLog';
import { FireabaseAdmin } from './services/FirebaseAdmin';
import { Util } from './util';

const SLACK_TOKEN = process.env.SLACK_TOKEN || 'slack_token';
const slackClient = new WebClient(SLACK_TOKEN);

const commandSet = {
  WORK: new Set(['ì¶œê·¼', 'ã…Šã„±', 'ã…Šã…Š', 'hi']),
  BYEBYE: new Set(['í‡´ê·¼', 'ã…Œã„±', 'bye']),
  REST: new Set(['íœ´ì‹', 'ã…ã……', 'rest', 'etc']),
  DONE: new Set(['ì™„ë£Œ', 'ã…‡ã„¹', 'done']),
  EMERGENCY: new Set(['ê¸´ê¸‰ëŒ€ì‘', 'ã„±ã„±ã„·ã…‡', 'emergency'])
};
const SLACK_ACTION_REQUEST_PING = 'ping-pong';

const viewerUrl: string = process.env.VIEWER_URL
  ? process.env.VIEWER_URL
  : 'http://localhost:3000';

const log = debug('tr:functions');
export async function commandPing(request, response) {
  if (request.method !== 'POST') {
    console.error(`Got unsupported ${request.method} request. Expected POST.`);
    return response.status(405).send('Only POST requests are accepted');
  }
  const command = request.body as SlackSlashCommand;
  // console.log(command);
  if (command.text === 'today') {
    const today = luxon.DateTime.local();
    return response
      .contentType('json')
      .status(200)
      .send({
        text: 'ğŸƒâ€â™€ï¸ì˜¤ëŠ˜ë„ í˜ë‚´ìš”!',
        attachments: [
          {
            title: 'ì˜¤ëŠ˜ ì›Œí¬ë¡œê·¸ ê¸°ë¡ í˜ì´ì§€ ë°”ë¡œê°€ê¸°',
            title_link: `${viewerUrl}/records/${
              command.user_id
            }?startDate=${today.toFormat(
              'yyyy-LL-dd'
            )}&endDate=${today.toFormat('yyyy-LL-dd')}`
          }
        ]
      });
  }
  // ì¶œê·¼
  if (commandSet.WORK.has(command.text) === true) {
    await WorkLog.storeWork({ userId: command.user_id });
    return response
      .contentType('json')
      .status(200)
      .send({
        text: Util.hiMsg()
      });
  }
  // í‡´ê·¼
  if (commandSet.BYEBYE.has(command.text) === true) {
    await WorkLog.storeBye({ userId: command.user_id });
    return response
      .contentType('json')
      .status(200)
      .send({
        text: Util.byeMsg()
      });
  }
  // íœ´ì‹
  if (commandSet.REST.has(command.text) === true) {
    await WorkLog.storeRest({ userId: command.user_id });
    return response
      .contentType('json')
      .status(200)
      .send({
        text: `íœ´ì‹ ${Util.dateTimeShort()}`
      });
  }
  // ê¸´ê¸‰ëŒ€ì‘
  if (commandSet.EMERGENCY.has(command.text) === true) {
    await WorkLog.storeEmergency({ userId: command.user_id });
    return response
      .contentType('json')
      .status(200)
      .send({
        text: `ê¸´ê¸‰ëŒ€ì‘ ${Util.dateTimeShort()}`
      });
  }
  // ì™„ë£Œ
  if (commandSet.DONE.has(command.text) === true) {
    const { msg } = await WorkLog.storeComplete({ userId: command.user_id });
    return response
      .contentType('json')
      .status(200)
      .send({
        text: msg
      });
  }
  // Handle the commands later, Slack expect this request to return within 3000ms
  // await FirebaseAmdin.Database.ref("commands/ping").push(command);
  return response
    .contentType('json')
    .status(200)
    .send({
      text: 'ê¸°ë¡ì„ ì‹œì‘í• ê¹Œìš”?',
      attachments: [
        {
          text: "Let's play the game.",
          fallback: 'You are unable to choose a game',
          callback_id: SLACK_ACTION_REQUEST_PING,
          color: '#3AA3E3',
          attachment_type: 'default',
          actions: [
            {
              name: 'game',
              text: 'ì¶œê·¼',
              type: 'button',
              value: EN_WORK_TYPE.WORK
            },
            {
              name: 'game',
              text: 'í‡´ê·¼',
              type: 'button',
              value: EN_WORK_TYPE.BYEBYE
            },
            {
              name: 'game',
              text: 'íœ´ì‹',
              type: 'button',
              value: EN_WORK_TYPE.REST
            },
            {
              name: 'game',
              text: 'ê¸´ê¸‰ëŒ€ì‘',
              style: 'danger',
              type: 'button',
              value: EN_WORK_TYPE.EMERGENCY,
              confirm: {
                title: 'ê¸´ê¸‰ëŒ€ì‘ ë¡œê·¸',
                text: 'ê¸´ê¸‰ëŒ€ì‘ì„ ì‹œì‘í• ê¹Œìš”? ã… ã… ',
                ok_text: 'Yes',
                dismiss_text: 'No'
              }
            },
            {
              name: 'game',
              text: 'ì™„ë£Œ',
              type: 'button',
              value: EN_WORK_TYPE.DONE
            }
          ]
        }
      ]
    });
}
/** ê´€ë¦¬ììš© */
export async function addWorkLog(request, res) {
  const {
    ...reqData
  }: {
    auth_user_id: string;
    user_id: string;
    type: EN_WORK_TYPE;
    target_date?: string;
    time?: string;
  } = request.body;
  // ë¡œê·¸ì¸ ì‚¬ìš©ì í™•ì¸
  const authInfo = await Users.findLoginUser({ userUid: reqData.auth_user_id });
  if (authInfo.result === false) {
    return res.status(401).send('unauthorized');
  }
  // ë‹¤ë¥¸ ìœ ì €ì˜ logë¥¼ ì¶”ê°€í•˜ëŠ”ê°€?
  if (authInfo.data.id !== reqData.user_id && !!authInfo.data.auth === false) {
    return res.status(401).send('unauthorized');
  }

  const target_date = !!reqData.target_date
    ? reqData.target_date
    : luxon.DateTime.local().toFormat('yyyy-LL-dd');
  const targetDay = luxon.DateTime.fromISO(target_date);

  // ê´€ë¦¬ìê°€ ì•„ë‹ˆë¼ë©´ í•´ë‹¹ ì£¼ì˜ ê¸°ë¡ì´ ì™„ë£Œëœ ìƒíƒœì¸ì§€ í™•ì¸í•œë‹¤.
  if (!!authInfo.data.auth === false) {
    // ì¼ìš”ì¼ì¸ê°€?
    const week =
      targetDay.weekday !== 7
        ? targetDay.toISOWeekDate().substr(0, 8)
        : targetDay
            .plus({ days: 1 })
            .toISOWeekDate()
            .substr(0, 8);
    const data = await WorkLog.findWeekOverWorkTime({
      login_auth_id: reqData.auth_user_id,
      weekKey: week
    });
    log('addWorkLog: ', week, data, data === null || data === undefined);
    // ë°ì´í„°ê°€ ìˆëŠ”ê°€?
    if ((data === null || data === undefined) === false) {
      return res.status(401).send('unauthorized(lock)');
    }
  }
  // ì™„ë£Œ ê¸°ë¡ì¸ê°€?
  if (reqData.type === EN_WORK_TYPE.DONE) {
    await WorkLog.storeComplete({
      userId: reqData.user_id,
      targetDate: reqData.target_date
    });
  } else if (
    reqData.type === EN_WORK_TYPE.VACATION ||
    reqData.type === EN_WORK_TYPE.HALFVACATION
  ) {
    // íœ´ê°€/ë°˜ì°¨ ê¸°ë¡(ê¸°ë¡ì€ ëª¨ë‘ VACATIONìœ¼ë¡œ í•œë‹¤.)
    const now = luxon.DateTime.local();
    const start = `${now.toFormat('yyyy-LL-dd')}T09:00:00+09:00`;
    const end = `${now.toFormat('yyyy-LL-dd')}T${
      reqData.type === EN_WORK_TYPE.VACATION ? 17 : 13
    }:00:00+09:00`;
    await WorkLog.store({
      userId: reqData.user_id,
      type: EN_WORK_TYPE.VACATION,
      targetDate: reqData.target_date,
      timeStr: start,
      doneStr: end
    });
  } else {
    const logs = await WorkLog.find({
      userId: reqData.user_id,
      startDate: reqData.target_date
    });
    const logDataList = Object.keys(logs.data).map(mv => logs.data[mv]);
    // ê²€ì¦ ë¡œì§ ì¶”ê°€.
    const possibleAddWorkLog = WorkLog.checkAddWorkType(
      logDataList,
      reqData.type
    );
    // ì¡°ê±´ì„ ë§Œì¡±í–ˆê±°ë‚˜, ê´€ë¦¬ì ê¶Œí•œì´ ìˆì„ ë•Œ!
    if (possibleAddWorkLog === true || !!authInfo.data.auth === true) {
      // ì™„ë£Œ ì™¸ì˜ ê¸°ë¡
      await WorkLog.store({
        userId: reqData.user_id,
        type: reqData.type,
        timeStr: reqData.time,
        targetDate: reqData.target_date
      });
    }
  }

  // ì¶œê·¼ ë¡œê·¸ ì¼ ë•Œ
  // ì§€ë‚œì£¼ ì •ì‚° ê¸°ë¡ì´ ì—†ê³ ,
  // ì§€ë‚œì£¼ ê·¼ë¬´ ì‹œê°„ì´ ë¶€ì¡±í•˜ë©´, ìŠ¬ë™ ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ë‹¤.
  if (
    reqData.type === EN_WORK_TYPE.WORK ||
    reqData.type === EN_WORK_TYPE.REMOTE
  ) {
    const lastWeek =
      targetDay.weekday !== 7
        ? targetDay
            .minus({ week: 1 })
            .toISOWeekDate()
            .substr(0, 8)
        : targetDay
            .minus({ week: 1 })
            .plus({ days: 1 })
            .toISOWeekDate()
            .substr(0, 8);
    const data = await WorkLog.findWeekOverWorkTime({
      login_auth_id: reqData.auth_user_id,
      weekKey: lastWeek
    });
    log({ data });
    // ì •ì‚° ë°ì´í„°ê°€ ìˆëŠ”ê°€?
    if ((data === null || data === undefined) === false) {
      return res.send();
    }
    const weekStartDay = luxon.DateTime.fromISO(`${lastWeek}-1`).minus({
      days: 1
    });
    const weekEndDay = luxon.DateTime.fromISO(`${lastWeek}-6`);
    // ì •ì‚° ê¸°ë¡ì´ ì—†ë‹¤ë©´. ì „ì²´ ê·¼ë¬´ ì‹œê°„ì„ í™•ì¸í•˜ì.
    const holidayDuration = await WorkLog.getHolidaysDuration(
      weekStartDay,
      weekEndDay
    );
    const time = await getTimeObj(
      lastWeek,
      reqData.user_id,
      reqData.auth_user_id,
      holidayDuration
    );
    const weekWorkingHours = 40 - holidayDuration.hours;
    const holidayCount = holidayDuration.hours / 8;

    // ê·¼ë¬´ ê¸°ë¡ì´ ìˆê³  ì‹œê°„ì´ + or 0ì´ë©´
    if (time.haveData === true) {
      await slackClient.chat.postMessage({
        channel: reqData.user_id,
        username: 'ì›Œí¬ë¡œê·¸',
        text: `í•œ ì£¼ë„ ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤
        \nê¸°ê°„: ${weekStartDay.toFormat('yyyy-LL-dd')} - ${weekEndDay.toFormat(
          'yyyy-LL-dd'
        )}
        \nê¸°ì¤€ê·¼ë¬´ì‹œê°„: ${weekWorkingHours} _(íœ´ì¼: ${holidayCount})
        \nê·¼ë¬´ì‹œê°„: ${time.convertData.calWorkTimeStr}\nì´ˆê³¼ì‹œê°„: ${
          time.convertData.overTimeStr
        }\n${
          time.timeObj.milliseconds < 0
            ? 'ê·¼ë¬´ ì‹œê°„ì´ ë¶€ì¡±í•˜ë„¤ìš”. í˜¹ì‹œ ëˆ„ë½ëœ í‡´ê·¼ ê¸°ë¡ì´ ì—†ëŠ”ì§€ `ê·¼ë¬´ê¸°ë¡ í™•ì¸í•˜ê¸°`ì„ í†µí•´ ì‚´í´ë³´ì„¸ìš”.'
            : ''
        }\nëˆ„ë½ëœ í‡´ê·¼/ì¬íƒê·¼ë¬´ ì¢…ë£Œ ë¡œê·¸ ìˆ˜: ${time.convertData.noPair}`,
        attachments: [
          {
            title: 'ê·¼ë¬´ê¸°ë¡ í™•ì¸í•˜ê¸°',
            title_link: `${viewerUrl}/records/${
              reqData.user_id
            }?startDate=${weekStartDay.toFormat(
              'yyyy-LL-dd'
            )}&endDate=${weekEndDay.toFormat('yyyy-LL-dd')}`
          },
          {
            text: `ì •ì‚°ì„ ì§„í–‰í• ê¹Œìš”?${
              time.timeObj.milliseconds < 0
                ? '\nì •ì‚° ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ì„¤ë ¹ ê·¼ë¬´ ì‹œê°„ì´ ë¶€ì¡±í•´ë„ ì •ì‚° ë©ë‹ˆë‹¤.'
                : ''
            }`,
            fallback: 'ì •ì‚°ì´ ì§„í–‰ë˜ì§€ ì•Šì•˜ì–´ìš”.',
            callback_id: 'wopr_game',
            color: '#3AA3E3',
            actions: [
              {
                name: 'game',
                text: `Yes(${lastWeek})`,
                type: 'button',
                value: `${lastWeek}`
              }
            ]
          }
        ]
      });
    }
  }

  return res.send();
}
export async function deleteWorkLog(req, res) {
  const {
    ...reqData
  }: {
    auth_user_id: string;
    user_id: string;
    target_date: string;
    log_id: string;
  } = req.body;
  // ë¡œê·¸ì¸ ì‚¬ìš©ì í™•ì¸
  const authInfo = await Users.findLoginUser({ userUid: reqData.auth_user_id });
  if (authInfo.result === false) {
    return res.status(401).send('unauthorized');
  }
  // ë‹¤ë¥¸ ìœ ì €ì˜ logë¥¼ ì¶”ê°€í•˜ëŠ”ê°€?
  if (authInfo.data.id !== reqData.user_id && !!authInfo.data.auth === false) {
    return res.status(401).send('unauthorized');
  }
  // ê´€ë¦¬ìê°€ ì•„ë‹ˆë¼ë©´ í•´ë‹¹ ì£¼ì˜ ê¸°ë¡ì´ ì™„ë£Œëœ ìƒíƒœì¸ì§€ í™•ì¸í•œë‹¤.
  if (!!authInfo.data.auth === false) {
    const target_date = !!reqData.target_date
      ? reqData.target_date
      : luxon.DateTime.local().toFormat('yyyy-LL-dd');
    const targetDay = luxon.DateTime.fromISO(target_date);
    // ì¼ìš”ì¼ì¸ê°€?
    const week =
      targetDay.weekday !== 7
        ? targetDay.toISOWeekDate().substr(0, 8)
        : targetDay
            .plus({ days: 1 })
            .toISOWeekDate()
            .substr(0, 8);
    const data = await WorkLog.findWeekOverWorkTime({
      login_auth_id: reqData.auth_user_id,
      weekKey: week
    });
    log('deleteWorkLog: ', week, data, data === null || data === undefined);
    // ë°ì´í„°ê°€ ìˆëŠ”ê°€?
    if ((data === null || data === undefined) === false) {
      return res.status(401).send('unauthorized(lock)');
    }
  }
  log(reqData);
  await WorkLog.delete({
    userId: reqData.user_id,
    targetDate: reqData.target_date,
    log_id: reqData.log_id
  });

  return res.send();
}
/** ì´ˆê³¼ê·¼ë¬´ ì‹œê°„ì„ ì°¨ê°í•˜ëŠ” ìš”ì²­ */
export async function addFuseWorkLog(request: Request, res: Response) {
  const {
    ...reqData
  }: {
    auth_user_id: string; // ë¡œê·¸ì¸í•œ auth id
    user_id: string; // slack id(ëŒ€ìƒì)
    target_date: string; // ë“±ë¡í•  ë‚ ì§œ
    duration: string; // ì–¼ë§ˆë‚˜ fuseí• ì§€(ISO8601 í˜•ì‹ìœ¼ë¡œ ë°›ìŒ https://en.wikipedia.org/wiki/ISO_8601#Durations)
    isVacation?: boolean; // ì´ˆê³¼ê·¼ë¬´ë¥¼ íœ´ê°€ë¡œ ë°”ê¾¸ëŠ” ìš”ì²­ì¸ì§€ í™•ì¸
    note?: string; // ì‚¬ìœ  ê°™ì€ê±¸ ì ì„ ë•Œ ì‚¬ìš©
  } = request.body;
  log(request.body);
  // ë¡œê·¸ì¸ ì‚¬ìš©ì í™•ì¸
  const authInfo = await Users.findLoginUser({ userUid: reqData.auth_user_id });
  if (authInfo.result === false) {
    return res.status(401).send('unauthorized');
  }
  // ë‹¤ë¥¸ ìœ ì €ì˜ logë¥¼ ì¶”ê°€í•˜ëŠ”ê°€?
  log(
    authInfo.data.id,
    authInfo.data.id !== reqData.user_id,
    !!authInfo.data.auth === false,
    authInfo.data.auth
  );
  if (authInfo.data.id !== reqData.user_id && !!authInfo.data.auth === false) {
    return res.status(401).send('unauthorized 2');
  }
  // ëŒ€ìƒìì˜ ì •ë³´ë¥¼ ë¡œë”©í•˜ì.
  // ë¡œê·¸ì¸í•œ ì‚¬ìš©ì ì „ì²´ ì •ë³´ë¥¼ í™•ì¸í•œ ë’¤ user_idì™€ ë§¤ì¹­ë˜ëŠ” ê²ƒì„ ì°¾ì•„ì•¼í•œë‹¤. ì™€ ì´ê±° ë”ëŸ½ê²Œ ë³µì¡í•œë°?
  const allLoginUsers = await Users.findAllLoginUser();
  const targetUser = allLoginUsers.find(fv => fv.id === reqData.user_id);
  // ì‚¬ìš©ìê°€ ì—†ëŠ”ê°€?
  if (targetUser === null || targetUser === undefined) {
    return res.status(204).send();
  }
  // ì´ˆê³¼ê·¼ë¬´ ë‚´ì—­ & ì‚¬ìš©í•œ ì´ˆê³ ê·¼ë¬´ ì‹œê°„ ë‚´ì—­ ì¡°íšŒ
  const [overTime, fuseTime] = await Promise.all([
    WorkLog.findAllOverWorkTime({ login_auth_id: targetUser.auth_id }),
    WorkLog.findAllFuseOverWorkTime({ login_auth_id: targetUser.auth_id })
  ]);
  if (overTime.length <= 0) {
    // ê¸°ë¡ì´ ì—†ìœ¼ë©´ fail
    return res.status(400).send(`ì°¨ê° ê°€ëŠ¥í•œ ì´ˆê³¼ê·¼ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤`);
  }
  const isVacation = Util.isNotEmpty(reqData.isVacation) && reqData.isVacation;
  // ì°¨ê°ì„ ìš”ì²­í•œ ì‹œê°„ë§Œí¼ ì „ì²´ ì‹œê°„ì„ ë³´ìœ í–ˆëŠ”ì§€ í™•ì¸í•œë‹¤.
  // ì¶”ê°€ë¡œ ì´ˆê³¼ê·¼ë¬´ì‹œê°„ 10ì‹œê°„ìœ¼ë¡œ íœ´ê°€ì²˜ëŸ¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì¸ì§€ ì²´í¬
  const fuseDuration = isVacation
    ? luxon.Duration.fromISO('PT10H')
    : luxon.Duration.fromISO(reqData.duration);
  if (isVacation === false && fuseDuration > luxon.Duration.fromISO('PT6H')) {
    return res.status(400).send(`6ì‹œê°„ ì´ìƒ ì°¨ê°ì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤`);
  }
  const totalOverWorkDuration = overTime.reduce(
    (acc: luxon.Duration, cur: IOverWork) => {
      if (cur.over === null || cur.over === undefined) {
        return acc;
      }
      const tempDuration = luxon.Duration.fromObject(cur.over);
      const updateAcc = acc.plus(tempDuration);
      return updateAcc;
    },
    luxon.Duration.fromObject({ milliseconds: 0 })
  );
  const totalFuseDuration = fuseTime.reduce(
    (acc: luxon.Duration, cur: IFuseOverWork) => {
      const tempDuration = luxon.Duration.fromISO(cur.use);
      const updateAcc = acc.plus(tempDuration);
      return updateAcc;
    },
    luxon.Duration.fromObject({ milliseconds: 0 })
  );
  const totalRemainDuration = totalOverWorkDuration.minus(totalFuseDuration);
  if (fuseDuration > totalRemainDuration) {
    return res.status(400).send(`ì°¨ê° ê°€ëŠ¥ ì‹œê°„ì„ ì´ˆê³¼í•œ ìš”ì²­ì…ë‹ˆë‹¤`);
  }
  // ì‚¬ìš© ê¸°ë¡ì„ ì¶”ê°€í•œë‹¤.
  // ì´ˆê³¼ê·¼ë¬´ë¥¼ íœ´ê°€ë¡œ ì‚¬ìš©í•˜ëŠ” ê²½ìš° 10ì‹œê°„ìœ¼ë¡œ ì°¨ê°í•œë‹¤.
  await WorkLog.addFuseOverWorkTime({
    login_auth_id: targetUser.auth_id,
    date: reqData.target_date,
    use: isVacation ? 'PT10H' : reqData.duration,
    note: Util.isNotEmpty(reqData.note) ? reqData.note : ''
  });
  // í•´ë‹¹ ë‚ ì§œì˜ ì›Œí¬ë¡œê·¸ì— ì°¨ê°ì„ ì¶”ê°€í•œë‹¤.
  const time = luxon.DateTime.fromFormat(reqData.target_date, 'yyyyLLdd');
  const timeStr = time.plus({ hours: 9 }).toISO();
  const addDuration = isVacation
    ? luxon.Duration.fromISO('PT8H')
    : luxon.Duration.fromISO(reqData.duration);
  const doneStr = time
    .plus({ hours: 9 })
    .plus(addDuration)
    .toISO();
  await WorkLog.store({
    userId: targetUser.id,
    timeStr,
    doneStr,
    targetDate: reqData.target_date,
    type: EN_WORK_TYPE.FUSEOVERLOAD
  });
  return res.send();
}
export async function commandHistory(request, response) {
  if (request.method !== 'POST') {
    console.error(`Got unsupported ${request.method} request. Expected POST.`);
    return response.status(405).send('Only POST requests are accepted');
  }
  const command = request.body as SlackSlashCommand;
  // console.log(command);
  const userRootRef = FireabaseAdmin.Database.ref('user');
  const userRef = userRootRef.child(command.user_id);
  const logDatas = await userRef
    .child(`${Util.currentDate()}`)
    .once('value')
    .then(snap => {
      const childData = snap.val() as { [key: string]: LogData };
      // ì¼í•œ ì‹œê°„ ë½‘ì•„ë‚´ì.
      // ì¶œ/í‡´ê·¼ í•„í„°
      const workFilter = Object.keys(childData)
        .filter(
          fv =>
            childData[fv].type === EN_WORK_TYPE.WORK ||
            childData[fv].type === EN_WORK_TYPE.BYEBYE
        )
        .map(mv => {
          return childData[mv];
        })
        .reduce(
          (acc: { acc: number; lastWorkTimeStamp: string }, cur: LogData) => {
            // ì¶œê·¼ì¸ê°€?
            if (cur.type === EN_WORK_TYPE.WORK) {
              acc.lastWorkTimeStamp = cur.time;
            }
            // í‡´ê·¼ì¸ê°€?
            if (cur.type === EN_WORK_TYPE.BYEBYE) {
              if (!!acc.lastWorkTimeStamp) {
                // ì• ì‹œê°„ë¶€í„° ë¹„êµí•´ì„œ ì‹œê°„ ì¶”ê°€í•˜ì.
                const duration = Util.getBetweenDuration(
                  acc.lastWorkTimeStamp,
                  cur.time
                );
                acc.acc += duration.as('hours');
              }
            }
            return acc;
          },
          {
            acc: 0,
            lastWorkTimeStamp: null
          }
        );
      // ì¶œê·¼ì€ ì°í˜”ì§€ë§Œ í‡´ê·¼ ê¸°ë¡ì´ ì—†ëŠ”ê°€?
      const noBye = !!workFilter.lastWorkTimeStamp && workFilter.acc === 0;
      if (noBye === true) {
        const current = Util.currentTimeStamp();
        const duration = Util.getBetweenDuration(
          workFilter.lastWorkTimeStamp,
          current
        );
        workFilter.acc += duration.as('hours');
      }
      return {
        ...workFilter,
        rawData: childData,
        noBye
      };
    });
  // log time ì°ê¸°.
  const message = [
    logDatas.acc > 0
      ? `ì›Œí‚¹íƒ€ì„: ${logDatas.acc} ì‹œê°„ ê¸°ë¡ì¤‘!`
      : 'ì˜¤ëŠ˜ì€ íœ´ê°€ì¸ê°€ë´ìš” :)'
  ];
  const keyLength = Object.keys(logDatas.rawData).length;
  if (keyLength > 0) {
    Object.keys(logDatas.rawData).map(key => {
      const data = logDatas.rawData[key];
      const done = !!data.done ? ` ~ ${Util.toDateTimeShort(data.done)}` : '';
      message.push(
        `${EN_WORK_TITLE_KR[data.type]} ğŸ‘‰ ${Util.toDateTimeShort(
          data.time
        )}${done}`
      );
    });
  }
  return response
    .contentType('json')
    .status(200)
    .send({
      text: message.join('\n\n')
    });
}
export async function modify(request, res) {
  if (request.method !== 'POST') {
    console.error(`Got unsupported ${request.method} request. Expected POST.`);
    return res.status(405).send('Only POST requests are accepted');
  }
  const {
    auth_user_id,
    user_id,
    update_date,
    record_key,
    target_key,
    time
  } = request.body;
  // ê¶Œí•œ í™•ì¸
  const authInfo = await Users.findLoginUser({ userUid: auth_user_id });
  if (authInfo.result === false) {
    return res.status(401).send('unauthorized');
  }

  // ë‹¤ë¥¸ ìœ ì €ì˜ ì •ë³´ë¥¼ ìˆ˜ì •í•˜ëŠ”ê°€?
  if (authInfo.data.id !== user_id && !!authInfo.data.auth === false) {
    return res.status(401).send('unauthorized');
  }
  // ê´€ë¦¬ìê°€ ì•„ë‹ˆë¼ë©´ í•´ë‹¹ ì£¼ì˜ ê¸°ë¡ì´ ì™„ë£Œëœ ìƒíƒœì¸ì§€ í™•ì¸í•œë‹¤.
  if (!!authInfo.data.auth === false) {
    const target_date = !!update_date
      ? update_date
      : luxon.DateTime.local().toFormat('yyyy-LL-dd');
    const targetDay = luxon.DateTime.fromISO(target_date);
    // ì¼ìš”ì¼ì¸ê°€?
    const weekStr =
      targetDay.weekday !== 7
        ? targetDay.toISOWeekDate().substr(0, 8)
        : targetDay
            .plus({ days: 1 })
            .toISOWeekDate()
            .substr(0, 8);
    const data = await WorkLog.findWeekOverWorkTime({
      login_auth_id: user_id,
      weekKey: weekStr
    });
    log('addWorkLog: ', weekStr, data, data === null || data === undefined);
    // ë°ì´í„°ê°€ ìˆëŠ”ê°€?
    if ((data === null || data === undefined) === false) {
      return res.status(401).send('unauthorized(lock)');
    }
  }
  const updateData = {
    userId: user_id,
    updateDate: update_date,
    updateRecordkey: record_key,
    updateDataKey: target_key,
    updateTime: time
  };
  // ë°ì´í„° ìˆ˜ì •
  await WorkLog.updateData(updateData);
  return res.send();
}
export async function getAll(request, response) {
  const userId = request.query['userId'];
  const startDate = request.query['startDate'];
  const endDate = request.query['endDate'];
  if (!!userId === false) {
    response
      .status(400)
      .contentType('json')
      .send([]);
  } else {
    const resp = await WorkLog.findAll({ userId, startDate, endDate });
    response.contentType('json').send(resp);
  }
}
export async function getGroups(request, response) {
  const groupId = request.query['groupId'];
  if (!!groupId === false) {
    return response
      .status(400)
      .contentType('json')
      .send([]);
  }
  const resp = await Users.findAllInGroup({ groupId });
  return response.contentType('json').send(resp);
}
export async function getAllGroupInfo(_, response) {
  const resp = await Users.findAllGroupInfo();
  return response.contentType('json').send(resp);
}
export async function addGroupInfo(request, response) {
  const { group_id, name, desc } = request.body;
  if (Util.isEmpty(group_id) || Util.isEmpty(name) || Util.isEmpty(desc)) {
    return response.status(400).end();
  }
  const resp = await Users.addGroup({ group_id, name, desc });
  return response.status(resp === true ? 200 : 400).end();
}
export async function deleteGroupInfo(request, response) {
  const { group_id } = request.params;
  if (Util.isEmpty(group_id)) {
    return response.status(400).end();
  }
  await Users.deleteGroup({ group_id });
  return response.status(200).end();
}
export async function getUser(request, response) {
  const userId = request.query['userId'];
  if (!!userId === false) {
    return response
      .status(400)
      .contentType('json')
      .send({});
  }
  const resp = await Users.find({ userId });
  return response.contentType('json').send(resp);
}
export async function messageAction(request, response) {
  if (request.method !== 'POST') {
    console.error(`Got unsupported ${request.method} request. Expected POST.`);
    return response.status(405).send('Only POST requests are accepted');
  }
  if (!request.body && request.body.payload) {
    return response.status(401).send('Bad formatted action response');
  }
  const action = JSON.parse(request.body.payload) as SlackActionInvocation;
  // console.log(action);
  /*
{ type: 'interactive_message',
actions: [ { name: 'game', type: 'button', value: 'work' } ],
callback_id: 'ping-pong',
team: { id: 'T07SR86Q5', domain: 'yanoljain' },
channel: { id: 'D41CGCTEG', name: 'directmessage' },
user: { id: 'U41A627S6', name: 'totuworld' },
action_ts: '1531237678.104528',
message_ts: '1531237675.000481',
attachment_id: '1',
token: 'Uib4ICnKtx3hVggqOK8rO9MF',
is_app_unfurl: false,
response_url: 'https://hooks.slack.com/actions/T07SR86Q5/395512897729/vBgtX9dmHkC9XZe1BDN3nP6W',
trigger_id: '397118842807.7909278821.7d4790b60fe730f2c4fa229e75848497' }
*/
  // TODO: actionsì˜ valueë¥¼ ë³´ê³  ê¸°ë¡ì„ ì‹œì‘í•˜ì.
  const workRef = FireabaseAdmin.Database.ref('work');
  const userRootRef = FireabaseAdmin.Database.ref('user');
  const userRef = userRootRef.child(action.user.id);
  // ì¶œê·¼?
  if (action.actions[0].value === EN_WORK_TYPE.WORK) {
    const time = Util.currentTimeStamp();
    const refKey = await workRef.push({
      user: action.user.id,
      log: EN_WORK_TYPE.WORK,
      time: time
    });
    await userRef
      .child(`${Util.currentDate()}`)
      .push({ refKey: refKey.key, time, type: EN_WORK_TYPE.WORK });
    return response
      .contentType('json')
      .status(200)
      .send({
        text: Util.hiMsg()
      });
  }
  // í‡´ê·¼?
  if (action.actions[0].value === EN_WORK_TYPE.BYEBYE) {
    const time = Util.currentTimeStamp();
    const refKey = await workRef.push({
      user: action.user.id,
      log: EN_WORK_TYPE.BYEBYE,
      time: time
    });
    await userRef
      .child(`${Util.currentDate()}`)
      .push({ refKey: refKey.key, time, type: EN_WORK_TYPE.BYEBYE });
    return response
      .contentType('json')
      .status(200)
      .send({
        text: Util.byeMsg()
      });
  }
  // íœ´ì‹
  if (action.actions[0].value === EN_WORK_TYPE.REST) {
    const time = Util.currentTimeStamp();
    const refKey = await workRef.push({
      user: action.user.id,
      log: EN_WORK_TYPE.REST,
      time: time
    });
    await userRef
      .child(`${Util.currentDate()}`)
      .push({ refKey: refKey.key, time, type: EN_WORK_TYPE.REST });
    return response
      .contentType('json')
      .status(200)
      .send({
        text: `íœ´ì‹ ${Util.dateTimeShort()}`
      });
  }
  // ê¸´ê¸‰ëŒ€ì‘
  if (action.actions[0].value === EN_WORK_TYPE.EMERGENCY) {
    const time = Util.currentTimeStamp();
    const refKey = await workRef.push({
      user: action.user.id,
      log: EN_WORK_TYPE.EMERGENCY,
      time: time
    });
    await userRef
      .child(`${Util.currentDate()}`)
      .push({ refKey: refKey.key, time, type: EN_WORK_TYPE.EMERGENCY });
    return response
      .contentType('json')
      .status(200)
      .send({
        text: `ê¸´ê¸‰ëŒ€ì‘ ${Util.dateTimeShort()}`
      });
  }
  // ì™„ë£Œ
  if (action.actions[0].value === EN_WORK_TYPE.DONE) {
    const time = Util.currentTimeStamp();
    const logDatas = await userRef
      .child(`${Util.currentDate()}`)
      .once('value')
      .then(snap => {
        const childData = snap.val() as { [key: string]: LogData };
        const keys = Object.keys(childData);
        const filter = keys.reduce(
          (acc: (LogData & { key: string })[], cur) => {
            const fv = childData[cur];
            const updateFv: LogData & { key: string } = { ...fv, key: cur };
            // REST, EMERGENCY ì¤‘ doneì´ ì—†ëŠ” ê²ƒ ì¶”ì¶œ
            if (
              (fv.type === EN_WORK_TYPE.REST ||
                fv.type === EN_WORK_TYPE.EMERGENCY) &&
              !!fv.done === false
            ) {
              acc.push(updateFv);
            }
            return acc;
          },
          [] as (LogData & { key: string })[]
        );
        return filter;
      });
    if (logDatas.length === 0) {
      // ë”±íˆ ì™„ë£Œí•  ì¡ì´ ì—†ë‹¤.
      return response
        .contentType('json')
        .status(200)
        .send({
          text: `ì™„ë£Œì²˜ë¦¬í•  ì´ë²¤íŠ¸ê°€ ì—†ì–´ìš”`
        });
    }
    const updateData = logDatas[logDatas.length - 1];
    const duration = Util.getBetweenDuration(updateData.time, time).toObject();
    const durationStr = Object.keys(duration)
      .map(key => `${duration[key]} ${key}`)
      .join(' ');
    const msg = `${
      EN_WORK_TITLE_KR[updateData.type]
    } ì™„ë£Œ (ì†Œìš”: ${durationStr})`;
    updateData.done = time;
    await userRef
      .child(`${Util.currentDate()}`)
      .child(updateData.key)
      .set(updateData);
    return response
      .contentType('json')
      .status(200)
      .send({
        text: msg
      });
  }
  return response
    .contentType('json')
    .status(200)
    .send('ì™„ë£Œ');
}
/** ì¶”ê°€ ê·¼ë¬´ ì‹œê°„ì„ ê¸°ë¡í•œë‹¤. */
export async function storeOverWorkTime(request: Request, response: Response) {
  const weekPtn = /[0-9]{4}-W[0-9]{2}/;
  // weekê°€ í•„ìš”í•˜ë‹¤. 2018-W21
  //   startëŠ” weekì˜ 1 - 1 days, endëŠ” weekì˜ 6
  // ê·¸ë¦¬ê³  ëˆ„êµ¬ì˜ ê¸°ë¡ì„ ì •ë¦¬í• ì§€ í•„ìš”í•˜ë‹¤.
  // auth_user_id
  const { week, auth_user_id, user_id } = request.body;
  if (week === null || week === undefined || weekPtn.test(week) === false) {
    return response
      .status(400)
      .send({ errorMessage: 'body.weekëŠ”  ISO 8601 ê·œê²©ì˜ week(2018-W36)' });
  }
  if (auth_user_id === null || auth_user_id === undefined) {
    return response
      .status(400)
      .send({ errorMessage: 'body.auth_user_id ëˆ„ë½' });
  }
  const timeObj = await getTimeObj(week, user_id, auth_user_id);
  if (timeObj.haveData === false) {
    return response.send({ week });
  }
  const storeData = await WorkLog.storeOverWorkTime({
    login_auth_id: auth_user_id,
    over_time_obj: timeObj.timeObj,
    week
  });
  return response.send(storeData);
}
async function getTimeObj(
  week: string,
  user_id: string,
  auth_user_id: string,
  holidayDuration?: luxon.Duration
) {
  const startDate = luxon.DateTime.fromISO(`${week}-1`).minus({ days: 1 });
  const endDate = luxon.DateTime.fromISO(`${week}-6`);
  // RDBë¼ë©´ rangeë¡œ ê¸‡ê² ì§€ë§Œ firebaseë‹ˆê¹Œ í›„ë£¨ë£© ë‹¤ ì½ì–´ì•¼ê² êµ°. í›„í›„í›„
  const datas = await WorkLog.findAllWithLuxonDateTime({
    startDate,
    endDate,
    userId: user_id
  });
  const haveData = Object.keys(datas).length > 0;
  const convertData = TimeRecord.convertWorkTime(
    datas,
    startDate.toJSDate(),
    endDate.toJSDate(),
    holidayDuration
  );
  const duration = luxon.Duration.fromObject(convertData.overTimeObj).as(
    'milliseconds'
  );
  if (convertData.overTimeIsMinus === true) {
    return { haveData, timeObj: { milliseconds: -duration }, convertData };
  }
  return { haveData, timeObj: { milliseconds: duration }, convertData };
}
/** ì¶”ê°€ ê·¼ë¬´ì‹œê°„ ì „ì²´ ê¸°ë¡ ì¡°íšŒ */
export async function findAllOverTime(request: Request, response: Response) {
  const { auth_user_id } = request.query;
  if (auth_user_id === null || auth_user_id === undefined) {
    return response
      .status(400)
      .send({ errorMessage: 'query.auth_user_id ëˆ„ë½' });
  }
  const datas = await WorkLog.findAllOverWorkTime({
    login_auth_id: auth_user_id
  });
  return response.send(datas);
}
export async function findAllFuseOverTime(
  request: Request,
  response: Response
) {
  const { auth_user_id } = request.query;
  if (auth_user_id === null || auth_user_id === undefined) {
    return response
      .status(400)
      .send({ errorMessage: 'query.auth_user_id ëˆ„ë½' });
  }
  const datas = await WorkLog.findAllFuseOverWorkTime({
    login_auth_id: auth_user_id
  });
  return response.send(datas);
}
export async function findAllOverTimeByUserId(
  request: Request,
  response: Response
) {
  const { user_id } = request.query;
  if (user_id === null || user_id === undefined) {
    return response.status(400).send({ errorMessage: 'query.user_id ëˆ„ë½' });
  }
  const allLoginUsers = await Users.findAllLoginUser();
  const targetUser = allLoginUsers.find(fv => fv.id === user_id);
  if (targetUser === null || targetUser === undefined) {
    return response.status(204).send();
  }
  const datas = await WorkLog.findAllOverWorkTime({
    login_auth_id: targetUser.auth_id
  });
  return response.send(datas);
}
export async function findWeekOverTimeByUserId(
  request: Request,
  response: Response
) {
  const { target_date } = request.params;
  const { user_id, auth_user_id } = request.query;
  if (
    (user_id === null || user_id === undefined) &&
    (auth_user_id === null || auth_user_id === undefined)
  ) {
    return response
      .status(400)
      .send({ errorMessage: 'query.user_id or query.auth_user_id ëˆ„ë½' });
  }
  // if (!!auth_user_id === true) {
  //   const authUserInfo = await Users.findLoginUserWithAuthUserId(auth_user_id);
  // }
  const allLoginUsers = await Users.findAllLoginUser();
  const targetUser = allLoginUsers.find(fv => fv.id === user_id);
  if (targetUser === null || targetUser === undefined) {
    return response.status(204).send();
  }
  const targetDay = luxon.DateTime.fromISO(target_date);
  // ì¼ìš”ì¼ì¸ê°€?
  const week =
    targetDay.weekday !== 7
      ? targetDay.toISOWeekDate().substr(0, 8)
      : targetDay
          .plus({ days: 1 })
          .toISOWeekDate()
          .substr(0, 8);
  const data = await WorkLog.findWeekOverWorkTime({
    login_auth_id: targetUser.auth_id,
    weekKey: week
  });
  if (data === null || data === undefined) {
    return response.status(204).send();
  }
  return response.send(data);
}
export async function findAllFuseOverTimeByUserId(
  request: Request,
  response: Response
) {
  const { user_id } = request.query;
  if (user_id === null || user_id === undefined) {
    return response.status(400).send({ errorMessage: 'query.user_id ëˆ„ë½' });
  }
  const allLoginUsers = await Users.findAllLoginUser();
  const targetUser = allLoginUsers.find(fv => fv.id === user_id);
  if (targetUser === null || targetUser === undefined) {
    return response.status(204).send();
  }
  const datas = await WorkLog.findAllFuseOverWorkTime({
    login_auth_id: targetUser.auth_id
  });
  return response.send(datas);
}
/** ëª¨ë“  ë¡œê·¸ì¸ ì‚¬ìš©ìì˜ ì¶”ê°€ ê·¼ë¬´ ì‹œê°„ì„ ê¸°ë¡í•œë‹¤. */
export async function updateAllUsersOverWorkTime(
  request: Request,
  response: Response
) {
  const weekPtn = /[0-9]{4}-W[0-9]{2}/;
  const { week } = request.body;
  if (week === null || week === undefined || weekPtn.test(week) === false) {
    return response
      .status(400)
      .send({ errorMessage: 'body.weekëŠ”  ISO 8601 ê·œê²©ì˜ week(2018-W36)' });
  }
  const startDate = luxon.DateTime.fromISO(`${week}-1`).minus({ days: 1 });
  const endDate = luxon.DateTime.fromISO(`${week}-6`);
  const [users, holidayDuration] = await Promise.all([
    Users.findAllLoginUser(),
    WorkLog.getHolidaysDuration(startDate, endDate)
  ]);
  const promises = users.map(async mv => {
    const timeObj = await getTimeObj(week, mv.id, mv.auth_id, holidayDuration);
    if (timeObj.haveData === true) {
      await WorkLog.storeOverWorkTime({
        login_auth_id: mv.auth_id,
        over_time_obj: timeObj.timeObj,
        week
      });
    }
  });
  while (promises.length > 0) {
    await promises.pop();
  }
  return response.send();
}
/** user_idë‚˜ auth_user_idë¡œ ì¶”ê°€ ê·¼ë¬´ ì‹œê°„ì„ ê¸°ë¡í•œë‹¤.  */
export async function updateUserOverWorkTime(
  request: Request,
  response: Response
) {
  const weekPtn = /[0-9]{4}-W[0-9]{2}/;
  const { week, user_id, auth_user_id } = request.body;
  if (Util.isEmpty(week) || weekPtn.test(week) === false) {
    return response
      .status(400)
      .send({ errorMessage: 'body.weekëŠ”  ISO 8601 ê·œê²©ì˜ week(2018-W36)' });
  }
  // user_idë‚˜ auth_user_idê°€ ì—†ëŠ”ê°€?
  if (Util.isEmpty(user_id) && Util.isEmpty(auth_user_id)) {
    return response.status(400).send({
      errorMessage: 'ëŒ€ìƒ ìœ ì €ê°€ ëˆ„êµ¬ì¸ì§€ ì•Œ ìˆ˜ ì—†ìŒ(user_id, auth_user_id)'
    });
  }
  const startDate = luxon.DateTime.fromISO(`${week}-1`).minus({ days: 1 });
  const endDate = luxon.DateTime.fromISO(`${week}-6`);
  const [users, holidayDuration] = await Promise.all([
    Users.findAllLoginUser(),
    WorkLog.getHolidaysDuration(startDate, endDate)
  ]);
  const targetUser = Util.isNotEmpty(user_id)
    ? users.find(fv => fv.id === user_id)
    : users.find(fv => fv.auth_id === auth_user_id);
  if (targetUser === null || targetUser === undefined) {
    return response.status(204).send();
  }
  const timeObj = await getTimeObj(
    week,
    targetUser.id,
    targetUser.auth_id,
    holidayDuration
  );
  if (timeObj.haveData === true) {
    await WorkLog.storeOverWorkTime({
      login_auth_id: targetUser.auth_id,
      over_time_obj: timeObj.timeObj,
      week
    });
  }
  return response.send();
}

export async function forceAddOverWorkTime(
  request: Request,
  response: Response
) {
  const weekPtn = /[0-9]{4}-W[0-9]{2}/;
  const { week, user_id, auth_user_id, milliseconds } = request.body;
  if (Util.isEmpty(week) || weekPtn.test(week) === false) {
    return response
      .status(400)
      .send({ errorMessage: 'body.weekëŠ”  ISO 8601 ê·œê²©ì˜ week(2018-W36)' });
  }
  // user_idë‚˜ auth_user_idê°€ ì—†ëŠ”ê°€?
  if (Util.isEmpty(user_id) && Util.isEmpty(auth_user_id)) {
    return response.status(400).send({
      errorMessage: 'ëŒ€ìƒ ìœ ì €ê°€ ëˆ„êµ¬ì¸ì§€ ì•Œ ìˆ˜ ì—†ìŒ(user_id, auth_user_id)'
    });
  }
  const [users] = await Promise.all([Users.findAllLoginUser()]);
  const targetUser = Util.isNotEmpty(user_id)
    ? users.find(fv => fv.id === user_id)
    : users.find(fv => fv.auth_id === auth_user_id);
  if (targetUser === null || targetUser === undefined) {
    return response.status(204).send();
  }
  const overTime = luxon.Duration.fromMillis(milliseconds);
  await WorkLog.storeOverWorkTime({
    login_auth_id: targetUser.auth_id,
    over_time_obj: overTime.toObject(),
    week
  });
  return response.send();
}
export async function updateAllUsersOverWorkTimeTodayWorkker(
  request: Request,
  response: Response
) {
  const weekPtn = /[0-9]{4}-W[0-9]{2}/;
  const { week, group_id } = request.body;
  if (week === null || week === undefined || weekPtn.test(week) === false) {
    return response
      .status(400)
      .send({ errorMessage: 'body.weekëŠ”  ISO 8601 ê·œê²©ì˜ week(2018-W36)' });
  }
  const startDate = luxon.DateTime.fromISO(`${week}-1`).minus({ days: 1 });
  const endDate = luxon.DateTime.fromISO(`${week}-6`);
  const haveGroupId =
    !(group_id === null || group_id === undefined) &&
    typeof group_id === 'string';
  const getUserFunc = haveGroupId
    ? Users.findAllInGroupLoginUsers({ groupId: group_id })
    : Users.findAllLoginUser();
  const [users, holidayDuration] = await Promise.all([
    getUserFunc,
    WorkLog.getHolidaysDuration(startDate, endDate)
  ]);
  const promises = users.map(async mv => {
    // ë‹¹ì¼ ì›Œí¬ ê¸°ë¡ì„ í™•ì¸ í•œ ë’¤ ì¶œê·¼ ë¡œê·¸ê°€ ìˆìœ¼ë©´ ì‘ë™í•œë‹¤.
    const today = luxon.DateTime.local()
      .setZone('Asia/Seoul')
      .toFormat('yyyy-MM-dd');
    const resp = await WorkLog.findAll({
      userId: mv.id,
      startDate: today,
      endDate: today
    });
    if (!!resp === true && resp.length > 0) {
      const first = resp[0];
      let haveWork = false;
      Object.keys(first).forEach(fv => {
        if (
          haveWork === false &&
          Object.keys(first[fv]).map(
            sfv => first[fv][sfv].type === EN_WORK_TYPE.WORK
          ).length > 0
        ) {
          haveWork = true;
        }
      });
      const timeObj = await getTimeObj(
        week,
        mv.id,
        mv.auth_id,
        holidayDuration
      );
      if (haveWork && timeObj.haveData === true) {
        await WorkLog.storeOverWorkTime({
          login_auth_id: mv.auth_id,
          over_time_obj: timeObj.timeObj,
          week
        });
      }
    }
  });
  while (promises.length > 0) {
    await promises.pop();
  }
  return response.send();
}

export async function deleteOverWorkTime(request: Request, response: Response) {
  const weekPtn = /[0-9]{4}-W[0-9]{2}/;
  const { week, user_id, auth_user_id } = request.body;
  log({ week, auth_user_id });
  if (Util.isEmpty(week) || weekPtn.test(week) === false) {
    return response
      .status(400)
      .send({ errorMessage: 'body.weekëŠ”  ISO 8601 ê·œê²©ì˜ week(2018-W36)' });
  }
  // user_idë‚˜ auth_user_idê°€ ì—†ëŠ”ê°€?
  if (Util.isEmpty(user_id) && Util.isEmpty(auth_user_id)) {
    return response.status(400).send({
      errorMessage: 'ëŒ€ìƒ ìœ ì €ê°€ ëˆ„êµ¬ì¸ì§€ ì•Œ ìˆ˜ ì—†ìŒ(user_id, auth_user_id)'
    });
  }
  const users = await Users.findAllLoginUser();
  const targetUser = Util.isNotEmpty(user_id)
    ? users.find(fv => fv.id === user_id)
    : users.find(fv => fv.auth_id === auth_user_id);
  if (targetUser === null || targetUser === undefined) {
    return response.status(204).send();
  }
  log({ targetUser });
  const result = await WorkLog.deleteOverWorkTime({
    week,
    login_auth_id: targetUser.auth_id
  });
  return response.json({ result });
}
export async function getHolidays(request: Request, response: Response) {
  const { start_date, end_date } = request.query;
  if (Util.isEmpty(start_date) || Util.isEmpty(end_date)) {
    return response
      .status(400)
      .send({ errorMessage: 'queryì— start_date, end_date ëˆ„ë½(yyyy-mm-dd)' });
  }
  const convertStartDate = luxon.DateTime.fromISO(start_date);
  const convertEndDate = luxon.DateTime.fromISO(end_date);
  const holidays = await WorkLog.getHolidays(convertStartDate, convertEndDate);
  return response.json(holidays);
}
export async function getUserQueue(req: Request, res: Response) {
  const { authId } = req.params;
  if (Util.isEmpty(authId)) {
    return res.status(400).send({ errorMessage: 'authIdê°€ í•„ìš”í•©ë‹ˆë‹¤.' });
  }
  const datas = await Users.findUserQueue({ userUid: authId });
  return res.json(datas);
}
export async function addUserQueue(req: Request, res: Response) {
  const { userId } = req.params;
  const { reqUserId } = req.body;
  const originUserInfo = await Users.getSlackUserInfo({ userId });
  if (Util.isEmpty(originUserInfo.auth_id)) {
    return res.status(400);
  }
  const [user, targetUserInfo] = await Promise.all([
    Users.findLoginUser({ userUid: originUserInfo.auth_id }),
    Users.find({ userId: reqUserId })
  ]);
  if (Util.isEmpty(user) || Util.isEmpty(targetUserInfo)) {
    return res
      .status(400)
      .send({ errorMessage: 'ìš”ì²­í•œ ì •ë³´ê°€ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤' });
  }
  await Users.addUserQueue({
    userUid: originUserInfo.auth_id,
    userInfo: targetUserInfo
  });
  const datas = await Users.findUserQueue({ userUid: originUserInfo.auth_id });
  return res.json(datas);
}
export async function deleteUserQueue(req: Request, res: Response) {
  const { authId, key } = req.params;
  const findUser = await Users.findLoginUser({ userUid: authId });
  if (Util.isEmpty(findUser)) {
    return res
      .status(400)
      .send({ errorMessage: 'ìš”ì²­í•œ ì •ë³´ê°€ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤' });
  }
  await Users.deleteUserQueue({ userUid: authId, key });
  const datas = await Users.findUserQueue({ userUid: authId });
  return res.json(datas);
}
export async function getAllSlackUserInfo(_: Request, res: Response) {
  const datas = await Users.findAllSlackUserInfo();
  return res.json(datas);
}

export async function newMsgAction(request: Request, response: Response) {
  if (request.method !== 'POST') {
    console.error(`Got unsupported ${request.method} request. Expected POST.`);
    return response.status(405).send('Only POST requests are accepted');
  }
  if (!!request.body === false || !!request.body.payload === false) {
    return response.status(401).send('Bad formatted action response');
  }

  const action = JSON.parse(request.body.payload) as SlackActionInvocation;
  const firstAction = action.actions[0];

  const now = new Date();
  now.setHours(now.getHours() + now.getTimezoneOffset() / -60);
  const today = now.toJSON().substr(0, 10);

  // poì¸ê°€?
  if (firstAction.value === 'cxpo') {
    response
      .contentType('json')
      .status(200)
      .send({
        text: `CXPO ë“±ë¡ ì™„ë£Œ\nì›Œí¬ë¡œê·¸ ì£¼ì†Œ\n${viewerUrl}/records/${action.user.id}?startDate=${today}&endDate=${today}\nì‚¬ìš©ë²•ì€ íŒ€ì—ì„œ ê°€ì´ë“œ í• êº¼ì—ìš”~`
      });
    return await Groups.addMemberToGroup({
      group_id: 'cxpo',
      user_id: action.user.id
    });
  }

  // devì¸ê°€?
  if (firstAction.value === 'cxdev') {
    response
      .contentType('json')
      .status(200)
      .send({
        text: `CXDEV ë“±ë¡ ì™„ë£Œ\nì›Œí¬ë¡œê·¸ ì£¼ì†Œ\n${viewerUrl}/records/${action.user.id}?startDate=${today}&endDate=${today}\nì‚¬ìš©ë²•ì€ íŒ€ì—ì„œ ê°€ì´ë“œ í• êº¼ì—ìš”~`
      });
    return await Groups.addMemberToGroup({
      group_id: 'cxdev',
      user_id: action.user.id
    });
  }

  if (/^([0-9]{4})-?W(5[0-3]|[1-4][0-9]|0[1-9])$/.test(firstAction.value)) {
    response
      .contentType('json')
      .status(200)
      .send({
        text: `${firstAction.value} ì •ì‚° ì‹œì‘ ğŸ‘€`
      });
    // í•´ë‹¹ ì£¼ì°¨ ì •ì‚° ìš”ì²­
    // ì •ì‚° api ì½œì„ ë³´ë‚¸ë‹¤.
    const weekStartDay = luxon.DateTime.fromISO(
      `${firstAction.value}-1`
    ).minus({ days: 1 });
    const weekEndDay = luxon.DateTime.fromISO(`${firstAction.value}-6`);
    // ì •ì‚° ê¸°ë¡ì´ ì—†ë‹¤ë©´. ì „ì²´ ê·¼ë¬´ ì‹œê°„ì„ í™•ì¸í•˜ì.
    const [users, holidayDuration] = await Promise.all([
      Users.findAllLoginUser(),
      WorkLog.getHolidaysDuration(weekStartDay, weekEndDay)
    ]);
    const targetUser = users.find(fv => fv.id === action.user.id);
    if (targetUser === null || targetUser === undefined) {
      return response.status(204).send();
    }
    const timeObj = await getTimeObj(
      firstAction.value,
      action.user.id,
      targetUser.auth_id,
      holidayDuration
    );
    if (timeObj.haveData === true) {
      await WorkLog.storeOverWorkTime({
        login_auth_id: targetUser.auth_id,
        over_time_obj: timeObj.timeObj,
        week: firstAction.value
      });
      await slackClient.chat.postMessage({
        channel: action.user.id,
        username: 'ì›Œí¬ë¡œê·¸',
        text: `${firstAction.value} ì •ì‚° ì™„ë£Œ ğŸ`,
        attachments: [
          {
            title: 'ì •ì‚°ê¸°ë¡ í™•ì¸í•˜ê¸°',
            title_link: `${viewerUrl}/overload/${action.user.id}`
          }
        ]
      });
    }
  }
  return response.status(201).send({
    text: 'ìˆ˜ì‹  ì™„ë£Œ'
  });
}

const baseDuration = 'PT10H';
const baseDurationMS = 60 * 60 * 10 * 1000; // 10ì‹œê°„ì„ msë¡œ ë‚˜íƒ€ëƒ„.

/** íŠ¹ì • íŒ€ì˜ fuseë¥¼ vacationìœ¼ë¡œ ì „í™˜í•œë‹¤. */
export async function addFuseToVacationForTeam(
  request: Request,
  res: Response
) {
  const {
    ...reqData
  }: {
    auth_user_id: string; // ë¡œê·¸ì¸í•œ auth id
    expireDate: string; // ë§Œë£Œ ë‚ ì§œ
    note: string; // ì‚¬ìœ  ê°™ì€ê±¸ ì ì„ ë•Œ ì‚¬ìš©
  } = request.body;
  const authInfo = await Users.findLoginUser({ userUid: reqData.auth_user_id });
  if (authInfo.result === false) {
    return res.status(401).send('unauthorized');
  }
  const groupId = request.params['groupId'];
  if (!!groupId === false) {
    return res
      .status(400)
      .contentType('json')
      .send([]);
  }
  const allLoginUsers = await Users.findAllLoginUser();
  const now = luxon.DateTime.local().toFormat('yyyyLLdd');
  const resp = await Users.findAllInGroup({ groupId });
  const successUsers = [];
  for (const user of resp) {
    // ì‚¬ìš©ì ì •ë³´ ì°¾ê¸°
    const targetUser = allLoginUsers.find(
      loginUser => loginUser.id === user.id
    );
    if (targetUser === null || targetUser === undefined) {
      continue;
    }
    // ì´ˆê³¼ê·¼ë¬´ì™€ ì‚¬ìš©í•œ ì´ˆê³¼ê·¼ë¬´ ë‚´ì—­ ì¡°íšŒ
    // ì´ˆê³¼ê·¼ë¬´ ë‚´ì—­ & ì‚¬ìš©í•œ ì´ˆê³ ê·¼ë¬´ ì‹œê°„ ë‚´ì—­ ì¡°íšŒ
    const [overTime, fuseTime] = await Promise.all([
      WorkLog.findAllOverWorkTime({ login_auth_id: targetUser.auth_id }),
      WorkLog.findAllFuseOverWorkTime({ login_auth_id: targetUser.auth_id })
    ]);
    if (overTime.length <= 0) {
      // ê¸°ë¡ì´ ì—†ìœ¼ë©´ fail
      continue;
    }
    // ì°¨ê°ì„ ìš”ì²­í•œ ì‹œê°„ë§Œí¼ ì „ì²´ ì‹œê°„ì„ ë³´ìœ í–ˆëŠ”ì§€ í™•ì¸í•œë‹¤(í˜„ì¬ëŠ” ê°•ì œë£°ë¡œ 10ì‹œê°„)
    const fuseDuration = luxon.Duration.fromISO(baseDuration);

    const totalOverWorkDuration = overTime.reduce(
      (acc: luxon.Duration, cur: IOverWork) => {
        if (cur.over === null || cur.over === undefined) {
          return acc;
        }
        const tempDuration = luxon.Duration.fromObject(cur.over);
        const updateAcc = acc.plus(tempDuration);
        return updateAcc;
      },
      luxon.Duration.fromObject({ milliseconds: 0 })
    );
    const totalFuseDuration = fuseTime.reduce(
      (acc: luxon.Duration, cur: IFuseOverWork) => {
        const tempDuration = luxon.Duration.fromISO(cur.use);
        const updateAcc = acc.plus(tempDuration);
        return updateAcc;
      },
      luxon.Duration.fromObject({ milliseconds: 0 })
    );
    const totalRemainDuration = totalOverWorkDuration.minus(totalFuseDuration);
    if (fuseDuration > totalRemainDuration) {
      // ì°¨ê° ê°€ëŠ¥ ì‹œê°„ì„ ì´ˆê³¼í•œ ìš”ì²­
      continue;
    }
    // ì†Œì§„ ê¸°ë¡ ì¶”ê°€(10ì‹œê°„ìœ¼ë¡œ ì°¨ê° ê¸°ë¡ì„ ë‚¨ê¸´ë‹¤)
    await WorkLog.addFuseOverWorkTime({
      login_auth_id: targetUser.auth_id,
      date: now,
      use: baseDuration,
      note: reqData.note
    });

    // ì´ˆê³¼ê·¼ë¬´ë¥¼ íœ´ê°€ë¡œ ë°”ê¾¼ ê¸°ë¡ì„ ë‚¨ê¸´ë‹¤.
    await WorkLog.addFuseToVacation({
      login_auth_id: targetUser.auth_id,
      expireDate: reqData.expireDate,
      note: reqData.note
    });
    successUsers.push(user);
  }
  return res.json(successUsers);
}

/** íŠ¹ì • ìœ ì €ì˜ ì´ˆê³¼ê·¼ë¬´ ì‹œê°„ì„ íœ´ê°€ê¸ˆê³ ë¡œ ë°”ê¿”ì„œ ë„£ìŒ */
export async function addFuseToVacation(request: Request, res: Response) {
  const {
    ...reqData
  }: {
    auth_user_id: string; // ë¡œê·¸ì¸í•œ auth id
    user_id: string; // slack id(ëŒ€ìƒì)
    expireDate: string; // ë§Œë£Œ ë‚ ì§œ
    note: string; // ì‚¬ìœ  ê°™ì€ê±¸ ì ì„ ë•Œ ì‚¬ìš©
  } = request.body;
  log(request.body);
  // ë¡œê·¸ì¸ ì‚¬ìš©ì í™•ì¸
  const authInfo = await Users.findLoginUser({ userUid: reqData.auth_user_id });
  if (authInfo.result === false) {
    return res.status(401).send('unauthorized');
  }
  // ë‹¤ë¥¸ ìœ ì €ì˜ logë¥¼ ì¶”ê°€í•˜ëŠ”ê°€?
  log(
    authInfo.data.id,
    authInfo.data.id !== reqData.user_id,
    !!authInfo.data.auth === false,
    authInfo.data.auth
  );
  if (authInfo.data.id !== reqData.user_id && !!authInfo.data.auth === false) {
    return res.status(401).send('unauthorized 2');
  }
  // ëŒ€ìƒìì˜ ì •ë³´ë¥¼ ë¡œë”©í•˜ì.
  // ë¡œê·¸ì¸í•œ ì‚¬ìš©ì ì „ì²´ ì •ë³´ë¥¼ í™•ì¸í•œ ë’¤ user_idì™€ ë§¤ì¹­ë˜ëŠ” ê²ƒì„ ì°¾ì•„ì•¼í•œë‹¤. ì™€ ì´ê±° ë”ëŸ½ê²Œ ë³µì¡í•œë°?
  const allLoginUsers = await Users.findAllLoginUser();
  const targetUser = allLoginUsers.find(fv => fv.id === reqData.user_id);
  // ì‚¬ìš©ìê°€ ì—†ëŠ”ê°€?
  if (targetUser === null || targetUser === undefined) {
    return res.status(204).send();
  }
  // ì´ˆê³¼ê·¼ë¬´ ë‚´ì—­ & ì‚¬ìš©í•œ ì´ˆê³ ê·¼ë¬´ ì‹œê°„ ë‚´ì—­ ì¡°íšŒ
  const [overTime, fuseTime] = await Promise.all([
    WorkLog.findAllOverWorkTime({ login_auth_id: targetUser.auth_id }),
    WorkLog.findAllFuseOverWorkTime({ login_auth_id: targetUser.auth_id })
  ]);
  if (overTime.length <= 0) {
    // ê¸°ë¡ì´ ì—†ìœ¼ë©´ fail
    return res.status(400).send(`ì°¨ê° ê°€ëŠ¥í•œ ì´ˆê³¼ê·¼ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤`);
  }
  // ì°¨ê°ì„ ìš”ì²­í•œ ì‹œê°„ë§Œí¼ ì „ì²´ ì‹œê°„ì„ ë³´ìœ í–ˆëŠ”ì§€ í™•ì¸í•œë‹¤(í˜„ì¬ëŠ” ê°•ì œë£°ë¡œ 10ì‹œê°„)
  const fuseDuration = luxon.Duration.fromISO(baseDuration);

  const totalOverWorkDuration = overTime.reduce(
    (acc: luxon.Duration, cur: IOverWork) => {
      if (cur.over === null || cur.over === undefined) {
        return acc;
      }
      const tempDuration = luxon.Duration.fromObject(cur.over);
      const updateAcc = acc.plus(tempDuration);
      return updateAcc;
    },
    luxon.Duration.fromObject({ milliseconds: 0 })
  );
  const totalFuseDuration = fuseTime.reduce(
    (acc: luxon.Duration, cur: IFuseOverWork) => {
      const tempDuration = luxon.Duration.fromISO(cur.use);
      const updateAcc = acc.plus(tempDuration);
      return updateAcc;
    },
    luxon.Duration.fromObject({ milliseconds: 0 })
  );
  const totalRemainDuration = totalOverWorkDuration.minus(totalFuseDuration);
  if (fuseDuration > totalRemainDuration) {
    return res.status(400).send(`ì°¨ê° ê°€ëŠ¥ ì‹œê°„ì„ ì´ˆê³¼í•œ ìš”ì²­ì…ë‹ˆë‹¤`);
  }
  // ì†Œì§„ ê¸°ë¡ ì¶”ê°€(10ì‹œê°„ìœ¼ë¡œ ì°¨ê° ê¸°ë¡ì„ ë‚¨ê¸´ë‹¤)
  const now = luxon.DateTime.local().toFormat('yyyyLLdd');
  await WorkLog.addFuseOverWorkTime({
    login_auth_id: targetUser.auth_id,
    date: now,
    use: baseDuration,
    note: reqData.note
  });

  // ì´ˆê³¼ê·¼ë¬´ë¥¼ íœ´ê°€ë¡œ ë°”ê¾¼ ê¸°ë¡ì„ ë‚¨ê¸´ë‹¤.
  await WorkLog.addFuseToVacation({
    login_auth_id: targetUser.auth_id,
    expireDate: reqData.expireDate,
    note: reqData.note
  });

  return res.send();
}

export async function addFuseToVacationByGroupID(
  request: Request,
  res: Response
) {
  const {
    ...reqData
  }: {
    expireDate: string; // ë§Œë£Œ ë‚ ì§œ
    note: string; // ì‚¬ìœ  ê°™ì€ê±¸ ì ì„ ë•Œ ì‚¬ìš©
    auth_id: string;
  } = request.body;
  log(request.body);

  const authInfo = await Users.findLoginUser({ userUid: reqData.auth_id });
  // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
  if (
    authInfo.result === false ||
    authInfo.data.auth === undefined ||
    authInfo.data.auth !== 10
  ) {
    return res.status(401).send('unauthorized');
  }

  // ê·¸ë£¹ idë¥¼ ì „í•´ë°›ì•„ì„œ ê·¸ ì•ˆì— ìˆëŠ” ì‚¬ëŒë“¤ì„ ì²˜ë¦¬í•´ë²„ë¦¬ì.
  const groupId = request.params['group_id'];
  if (!!groupId === false) {
    return res.status(400).send();
  }

  // ëŒ€ìƒìì˜ ì •ë³´ë¥¼ ë¡œë”©í•˜ì.
  const groupUsers = await Users.findAllInGroup({ groupId });
  // ë¡œê·¸ì¸í•œ ì‚¬ìš©ì ì „ì²´ ì •ë³´ë¥¼ í™•ì¸í•œ ë’¤ user_idì™€ ë§¤ì¹­ë˜ëŠ” ê²ƒì„ ì°¾ì•„ì•¼í•œë‹¤. ì™€ ì´ê±° ë”ëŸ½ê²Œ ë³µì¡í•œë°?
  const allLoginUsers = await Users.findAllLoginUser();

  for (const user of groupUsers) {
    const targetUser = allLoginUsers.find(fv => fv.id === user.id);
    // ì‚¬ìš©ìê°€ ì—†ëŠ”ê°€?
    if (targetUser === null || targetUser === undefined) {
      continue;
    }
    // ì´ˆê³¼ê·¼ë¬´ ë‚´ì—­ & ì‚¬ìš©í•œ ì´ˆê³ ê·¼ë¬´ ì‹œê°„ ë‚´ì—­ ì¡°íšŒ
    const [overTime, fuseTime] = await Promise.all([
      WorkLog.findAllOverWorkTime({ login_auth_id: targetUser.auth_id }),
      WorkLog.findAllFuseOverWorkTime({ login_auth_id: targetUser.auth_id })
    ]);
    if (overTime.length <= 0) {
      // ê¸°ë¡ì´ ì—†ìœ¼ë©´ fail
      // ì°¨ê° ê°€ëŠ¥í•œ ì´ˆê³¼ê·¼ë¬´ê°€ ì—†ìŠµë‹ˆë‹¤
      continue;
    }
    // ì°¨ê°ì„ ìš”ì²­í•œ ì‹œê°„ë§Œí¼ ì „ì²´ ì‹œê°„ì„ ë³´ìœ í–ˆëŠ”ì§€ í™•ì¸í•œë‹¤(í˜„ì¬ëŠ” ê°•ì œë£°ë¡œ 10ì‹œê°„)
    const fuseDuration = luxon.Duration.fromISO(baseDuration);

    const totalOverWorkDuration = overTime.reduce(
      (acc: luxon.Duration, cur: IOverWork) => {
        if (cur.over === null || cur.over === undefined) {
          return acc;
        }
        const tempDuration = luxon.Duration.fromObject(cur.over);
        const updateAcc = acc.plus(tempDuration);
        return updateAcc;
      },
      luxon.Duration.fromObject({ milliseconds: 0 })
    );
    const totalFuseDuration = fuseTime.reduce(
      (acc: luxon.Duration, cur: IFuseOverWork) => {
        const tempDuration = luxon.Duration.fromISO(cur.use);
        const updateAcc = acc.plus(tempDuration);
        return updateAcc;
      },
      luxon.Duration.fromObject({ milliseconds: 0 })
    );
    const totalRemainDuration = totalOverWorkDuration.minus(totalFuseDuration);
    if (fuseDuration > totalRemainDuration) {
      // ì°¨ê° ê°€ëŠ¥ ì‹œê°„ì„ ì´ˆê³¼í•œ ìš”ì²­ì…ë‹ˆë‹¤
      continue;
    }
    // ì¶”ê°€í•  íœ´ê°€ ê°¯ìˆ˜ ì¹´ìš´íŠ¸
    const totalAddVacationCount = (() => {
      let nowRemainDuration = luxon.Duration.fromObject(
        totalRemainDuration.toObject()
      );
      let count = 0;
      while (nowRemainDuration > fuseDuration) {
        count += 1;
        nowRemainDuration = nowRemainDuration.minus({
          milliseconds: baseDurationMS
        });
      }
      return count;
    })();
    // ì†Œì§„ ê¸°ë¡ ì¶”ê°€(10ì‹œê°„ìœ¼ë¡œ ì°¨ê° ê¸°ë¡ì„ ë‚¨ê¸´ë‹¤)
    const now = luxon.DateTime.local().toFormat('yyyyLLdd');
    for (let i = 0; i < totalAddVacationCount; i++) {
      await WorkLog.addFuseOverWorkTime({
        login_auth_id: targetUser.auth_id,
        date: now,
        use: baseDuration,
        note: reqData.note
      });

      // ì´ˆê³¼ê·¼ë¬´ë¥¼ íœ´ê°€ë¡œ ë°”ê¾¼ ê¸°ë¡ì„ ë‚¨ê¸´ë‹¤.
      await WorkLog.addFuseToVacation({
        login_auth_id: targetUser.auth_id,
        expireDate: reqData.expireDate,
        note: reqData.note
      });
    }
    await slackClient.chat.postMessage({
      channel: 'zin_worklog',
      username: 'ì›Œí¬ë¡œê·¸',
      text: `ì´ˆê³¼ê·¼ë¬´ --> íœ´ê°€ê¸ˆê³  ë³€í™˜ ì™„ë£Œ ğŸ`,
      attachments: [
        {
          title: 'ì‚¬ìš©ì id',
          text: targetUser.id
        },
        {
          title: 'ë³€í™˜ëœ íœ´ê°€ ê°¯ìˆ˜',
          text: totalAddVacationCount.toString()
        },
        {
          title: 'ë³€í™˜ ì‚¬ìœ ',
          text: reqData.note
        },
        {
          title: 'ë§Œë£Œì¼',
          text: reqData.expireDate
        },
        {
          title: 'íœ´ê°€ê¸ˆê³  í™•ì¸í•˜ê¸°',
          title_link: `${viewerUrl}/convert_vacation/${targetUser.id}`
        }
      ]
    });
  }

  return res.send();
}

export async function findAllFuseToVacationByUserId(
  request: Request,
  response: Response
) {
  const { user_id } = request.params;
  const { filter_possible } = request.query;
  if (user_id === null || user_id === undefined) {
    return response.status(400).send({ errorMessage: 'query.user_id ëˆ„ë½' });
  }
  const filterPossible =
    filter_possible === null || filter_possible === undefined
      ? false
      : filter_possible === 'true';
  const allLoginUsers = await Users.findAllLoginUser();
  const targetUser = allLoginUsers.find(fv => fv.id === user_id);
  if (targetUser === null || targetUser === undefined) {
    return response.status(204).send();
  }
  const datas = await WorkLog.findAllFuseToVacation({
    login_auth_id: targetUser.auth_id,
    filterPossible
  });
  return response.send(datas);
}

/** ì´ˆê³¼ê·¼ë¬´ì‹œê°„ ì „í™˜í•œ íœ´ê°€ ì‚¬ìš©í•˜ê¸° */
export async function useFuseToVacation(request: Request, res: Response) {
  const {
    ...reqData
  }: {
    auth_user_id: string; // ë¡œê·¸ì¸í•œ auth id
    user_id: string; // slack id(ëŒ€ìƒì)
    target_date: string; // ë“±ë¡í•  ë‚ ì§œ
  } = request.body;
  log(request.body);
  // ë¡œê·¸ì¸ ì‚¬ìš©ì í™•ì¸
  const authInfo = await Users.findLoginUser({ userUid: reqData.auth_user_id });
  if (authInfo.result === false) {
    return res.status(401).send('unauthorized');
  }
  // ë‹¤ë¥¸ ìœ ì €ì˜ logë¥¼ ì¶”ê°€í•˜ëŠ”ê°€?
  log(
    authInfo.data.id,
    authInfo.data.id !== reqData.user_id,
    !!authInfo.data.auth === false,
    authInfo.data.auth
  );
  if (authInfo.data.id !== reqData.user_id && !!authInfo.data.auth === false) {
    return res.status(401).send('unauthorized 2');
  }

  const allLoginUsers = await Users.findAllLoginUser();
  const targetUser = allLoginUsers.find(fv => fv.id === reqData.user_id);

  // ì´ˆê³¼ê·¼ë¬´ íœ´ê°€ ì‚¬ìš© ê¸°ë¡ ë‚¨ê¸´ë‹¤.
  const time = luxon.DateTime.fromFormat(reqData.target_date, 'yyyyLLdd');
  const result = await WorkLog.useFuseToVacation({
    login_auth_id: targetUser.auth_id,
    addLogDate: reqData.target_date
  });
  if (result === true) {
    const timeStr = time.plus({ hours: 9 }).toISO();
    const addDuration = luxon.Duration.fromISO('PT8H');
    const doneStr = time
      .plus({ hours: 9 })
      .plus(addDuration)
      .toISO();
    await WorkLog.store({
      userId: targetUser.id,
      timeStr,
      doneStr,
      targetDate: reqData.target_date,
      type: EN_WORK_TYPE.FUSEOVERLOAD
    });
  }

  return res.send({ result });
}

export async function disableExpiredFuseToVacation(
  request: Request,
  res: Response
) {
  // ê·¸ë£¹ idë¥¼ ì „í•´ë°›ì•„ì„œ ê·¸ ì•ˆì— ìˆëŠ” ì‚¬ëŒë“¤ì„ ì²˜ë¦¬í•´ë²„ë¦¬ì.
  const groupId = request.params['group_id'];
  if (!!groupId === false) {
    return res.status(400).send();
  }
  const { expireDate, expireNote, auth_id } = request.body;
  const authInfo = await Users.findLoginUser({ userUid: auth_id });
  // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
  if (
    authInfo.result === false ||
    authInfo.data.auth === undefined ||
    authInfo.data.auth !== 10
  ) {
    return res.status(401).send('unauthorized');
  }
  const groupUsers = await Users.findAllInGroup({ groupId });
  const allLoginUsers = await Users.findAllLoginUser();

  for (const user of groupUsers) {
    const targetUser = allLoginUsers.find(fv => fv.id === user.id);
    // ë¡œê·¸ì¸ ìœ ì € ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìœ¼ë©´ ì²˜ë¦¬í•˜ì§€ ì•ŠëŠ”ë‹¤.
    // auth_idë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ë„ ì²˜ë¦¬í•˜ì§€ ì•ŠëŠ”ë‹¤.
    if (
      targetUser === undefined ||
      targetUser === null ||
      targetUser.auth_id === undefined ||
      targetUser.auth_id === null
    ) {
      continue;
    }
    await WorkLog.disableExpireFuseToVacation({
      login_auth_id: targetUser.auth_id,
      expDate: expireDate,
      expireNote
    });
    await slackClient.chat.postMessage({
      channel: 'zin_worklog',
      username: 'ì›Œí¬ë¡œê·¸',
      text: `ì‚¬ë¦¬ì§„ íœ´ê°€ê¸ˆê³  ì•ˆë‚´ ğŸ˜­`,
      attachments: [
        {
          title: 'ì‚¬ìš©ì id',
          text: targetUser.id
        },
        {
          title: 'ë§Œë£Œ ì‚¬ìœ ',
          text: expireNote
        },
        {
          title: 'ë§Œë£Œ ê¸°ì¤€ì¼',
          text: expireDate
        },
        {
          title: 'íœ´ê°€ê¸ˆê³  í™•ì¸í•˜ê¸°',
          title_link: `${viewerUrl}/convert_vacation/${targetUser.id}`
        }
      ]
    });
  }
  return res.send('done');
}
